# Noridoc: installer

Path: @/plugin/src/installer

### Overview

CLI installer for Nori Profiles that prompts for configuration, installs features into Claude Code, manages credentials, and tracks installation analytics via Google Analytics, supporting both free (local-only) and paid (backend-integrated) installation modes with directory-based profile system. The CLI uses Commander.js for command routing, argument parsing, and help generation.

### How it fits into the larger codebase

**CLI Architecture:** The nori-ai CLI command (defined in @/plugin/package.json bin) routes to @/plugin/src/installer/cli.ts, which uses Commander.js for command routing, argument parsing, validation, and help generation. The CLI defines global options (`--install-dir`, `--non-interactive`) on the main program. Each installer file (install.ts, uninstall.ts) exports a `registerXCommand({ program })` function that configures the commander program with command name, description, and action handler. The check and switch-profile commands are defined directly in cli.ts since they don't have dedicated installer files. Commands access global options via `program.opts()`. The CLI provides automatic `--help`, `--version`, and unknown command detection. Running `nori-ai` with no command defaults to `install`. The CLI layer is responsible ONLY for parsing and routing - all business logic remains in the main/runUninstall functions.

**Installation Flow:** The installer (install.ts) orchestrates the installation process by prompting for credentials (prompt.ts), selecting a profile from available directories, loading/saving configuration (config.ts), and executing feature loaders from @/plugin/src/installer/features. It creates `<installDir>/.nori-config.json` containing auth credentials and selected profile name, and installs components into `<installDir>/.claude/`. By default, installDir is `process.cwd()`, so running `cd /project && npx nori-ai install` creates files in `/project/`. The profile selection determines which complete directory structure (CLAUDE.md, skills/, subagents/, slashcommands/) gets installed from @/plugin/src/installer/features/profiles/config/{profileName}/. Each profile is a self-contained directory with a CLAUDE.md file that defines the profile. Profiles are discovered dynamically by scanning for directories containing CLAUDE.md in @/plugin/src/installer/features/profiles/config/. The installer is also used by the uninstaller (uninstall.ts) which removes installed components. The analytics.ts module tracks installation events to Google Analytics using Firebase, providing visibility into installation patterns and user adoption. Profile switching is handled by profiles.ts (switchProfile, listProfiles) which preserves auth credentials while updating the selected profile.

**installDir Architecture:** The codebase follows a strict pattern where `installDir` is a required parameter for all internal functions. CLI entry points (install.ts:main, uninstall.ts:main, cli.ts:checkMain, profiles.ts:switchProfile) are the ONLY places that accept optional installDir. These entry points call normalizeInstallDir() from @/plugin/src/utils/path.ts at the top to convert the optional parameter to a required string, then pass it to all downstream functions. The `installDir` is the BASE directory (e.g., `/home/user/project`), NOT the `.claude` directory. All files are stored relative to this base:
- `<installDir>/.nori-config.json` - config file (via getConfigPath)
- `<installDir>/.nori-installed-version` - version tracking (via getVersionFilePath)
- `<installDir>/.claude/` - Claude Code configuration (via getClaudeDir)

This ensures that when running `cd /foo/bar && npx nori-ai install`, all files are created in `/foo/bar/` rather than the user's home directory.

The install.ts main function first normalizes installDir via `const normalizedInstallDir = normalizeInstallDir({ installDir })`, then checks for Nori installations in ancestor directories using findAncestorInstallations() from @/plugin/src/utils/path.ts. If any are found, it displays a warning explaining that Claude Code loads CLAUDE.md files from all parent directories, lists the ancestor installation paths, and provides uninstall commands. In interactive mode, it prompts for confirmation before proceeding; in non-interactive mode (e.g., autoupdate), it warns and continues. After the ancestor check, install.ts checks if an existing installation exists using hasExistingInstallation({ installDir: normalizedInstallDir }) from version.ts, which returns true if the version file (`<installDir>/.nori-installed-version`) exists OR if the config file (`<installDir>/.nori-config.json`) exists. The required installDir parameter ensures consistent checking - both the version check and config file check use the same directory context. If an installation exists, it runs uninstall for the previously installed version (tracked via version.ts) to ensure clean upgrades, UNLESS the optional skipUninstall parameter is true. The skipUninstall parameter is used during profile switching (see @/plugin/src/installer/cli.ts switch-profile command) to preserve custom user profiles that would otherwise be removed during uninstall. If no installation exists (first-time install), it skips the uninstall step and displays "First-time installation detected." This prevents confusing cleanup messages for first-time users. After the conditional uninstall, it displays the NORI ASCII art banner via asciiArt.ts in interactive mode. The promptForConfig function handles two flows: (1) interactive - prompts for credentials via promptForCredentials, then profile selection via promptForProfileSelection which dynamically discovers profiles by scanning for directories with CLAUDE.md, (2) non-interactive - uses existing config from disk or defaults to free mode with senior-swe profile. The config.ts module manages DiskConfig (credentials + profile.baseProfile + installDir) and runtime Config (installType + profile.baseProfile + installDir). Both types now require installDir as a field. After saving config, the LoaderRegistry from features/loaderRegistry.ts executes all feature loaders sequentially. Key loaders: (1) profiles loader copies entire profile directories from @/plugin/src/installer/features/profiles/config/ to `<installDir>/.claude/profiles/`, (2) claudemd loader reads the selected profile's CLAUDE.md, appends a dynamically-generated skills list by globbing for \*\*/SKILL.md files in the profile's skills/ directory, and embeds everything in a managed block, (3) skills/subagents/slashcommands loaders copy files from the profile's respective subdirectories to `<installDir>/.claude/`. The installer tracks plugin_install_started and plugin_install_completed events with install_type and non_interactive parameters, and saves the current version using saveInstalledVersion for future upgrade cleanup.

The uninstall.ts module removes all Nori-installed components from the system. The main() entry point accepts an optional installDir that gets normalized by normalizeInstallDir() from @/plugin/src/utils/path.ts. In interactive mode, the promptForUninstall() function first checks if the current installDir has a Nori installation using hasNoriInstallation() from @/plugin/src/utils/path.ts. If no local installation exists, it searches for ancestor installations using findAncestorInstallations(), which returns an array of ancestor directories ordered from closest to furthest. The UX handles three scenarios: (1) no installation found anywhere - displays "No Nori installation found in current or ancestor directories" and exits gracefully, (2) exactly one ancestor installation - displays "No Nori installation found in current directory" and "Found installation in ancestor directory: {path}", then prompts "Uninstall from this ancestor location? (y/n)" - if the user confirms, installDir is updated to the ancestor path and uninstall proceeds, (3) multiple ancestor installations - displays "No Nori installation found in current directory" and "Found installations in ancestor directories:" with numbered options (1, 2, 3...), then prompts "Select installation to uninstall (1-N), or 'n' to cancel" - the user can select a number or type 'n' to cancel; invalid selections display "Invalid selection. Uninstallation cancelled." Non-interactive mode bypasses ancestor detection and operates strictly on the provided installDir to preserve autoupdate workflow expectations where uninstall should only operate on the specific installation directory being upgraded. After ancestor detection (if applicable), promptForUninstall() loads the config and displays standard uninstall prompts. The runUninstall() function executes loaders in reverse order using registry.getAllReversed() - this is critical because during install, profiles must run first to create profile directories that other loaders read from, but during uninstall, profiles must run last so slashcommands, subagents, and other loaders can still access profile directories to determine which files to remove. After all loaders complete their individual cleanup, uninstall.ts performs central cleanup: cleanupEmptyDirectories() removes ~/.claude/agents/ and ~/.claude/commands/ if they're empty (preserving user-created content), and cleanupNotificationsLog() removes ~/.nori-notifications.log. Config file removal (~/nori-config.json and ~/.nori-installed-version) only happens when removeConfig=true (user-initiated uninstall via main()), not during upgrade uninstalls where config is preserved.

The version.ts module manages version tracking for installation upgrades. The getVersionFilePath() function requires { installDir: string } and returns `<installDir>/.nori-installed-version`. All version file operations (hasExistingInstallation, getInstalledVersion, saveInstalledVersion) require installDir as a parameter. The hasExistingInstallation function checks both the version file and config file existence to determine if an installation exists, returning true if either `<installDir>/.nori-installed-version` OR `<installDir>/.nori-config.json` exists. This ensures that old installations (before version tracking was added) are still detected via the config file.

The logger.ts module provides console output formatting with ANSI color codes. Standard logging functions (error, success, info, warn, debug) use colors.RED, colors.GREEN, colors.BLUE, colors.YELLOW respectively. Additional formatting helpers (brightCyan, boldWhite, gray) use formatColors for enhanced visual hierarchy in CLI output - these return strings with ANSI codes applied. All log functions in logger.ts also append to /tmp/nori-installer.log asynchronously for debugging. The promptForProfileSelection function in install.ts uses these formatters to display profile options with brightCyan numbers, boldWhite names, and gray indented descriptions, separated by blank lines for improved scannability. The promptForCredentials function displays a wrapped prompt asking users to enter credentials or skip for free tier.

The config.ts module manages three types of configuration: (1) DiskConfig stored in `.nori-config.json` containing auth credentials, profile selection, user preferences like sendSessionTranscript, and the required installDir field, (2) runtime Config derived from DiskConfig for feature loaders, also containing the required installDir field. The getConfigPath() function requires { installDir: string } and returns `<installDir>/.nori-config.json`. All config operations (loadDiskConfig, saveDiskConfig, validateDiskConfig, generateConfig) require installDir as a parameter, ensuring consistent path resolution throughout the codebase. The sendSessionTranscript field ('enabled' | 'disabled') defaults to 'enabled' when not present in config file, maintaining backward compatibility. This field is loaded by loadDiskConfig() with default fallback, persisted by saveDiskConfig() when provided, and validated by the JSON schema. The config.ts module is used by both the installer (for managing installation settings) and hooks (for reading user preferences like session transcript opt-out).

**loadDiskConfig() installDir Resolution:** The loadDiskConfig() function returns a DiskConfig object where the installDir field comes from the JSON file (if present) rather than exclusively from the function parameter. The parameter provides a default, but the function prioritizes `config.installDir` from the saved JSON file if it exists. This is critical because @/plugin/src/installer/features/hooks/config/autoupdate.ts searches for the config file in parent directories - it must use the installDir from the config file itself, not the directory where the config was found. For example, if Nori was installed at `~/` but Claude Code is running from `~/foo/bar`, the config file is found at `~/.nori-config.json` (via ancestor search), but the actual installDir stored in that file is `~`, so the hook must use `~` as the installDir, not `~/foo/bar`.

Note: Hook scripts (autoupdate, summarize, etc.) use `process.cwd()` at runtime since they're called by Claude Code in the context of the user's project directory, but they search upward through parent directories to find the config file and read the true installDir from it.

### Things to Know

The installer modifies several Claude Code configuration files and directories: claude_desktop_config.json, CLAUDE.md, ~/.claude/hooks, ~/.claude/subagents, ~/.claude/slash-commands, ~/.claude/status-line, ~/.claude/profiles, ~/.claude/skills. Profiles are complete, self-contained directory structures at @/plugin/src/installer/features/profiles/config/{profileName}/ containing: CLAUDE.md (base instructions), PROFILE.md (description), skills/ (skill directories with SKILL.md files), subagents/ (subagent .md files), slashcommands/ (slash command .md files). The profile discovery mechanism in install.ts scans for any directory with a CLAUDE.md file, making it easy to add new profiles by creating a new directory. Each profile is installed to ~/.claude/profiles/{profileName}/ with the same structure. Built-in profiles (those with `"builtin": true` in profile.json) are identified by metadata and only built-in profiles are removed during uninstall operations, allowing custom user profiles to persist across profile switches and upgrades. The CLAUDE.md managed block contains both the profile's base instructions AND a dynamically-generated skills list created by globbing for all SKILL.md files in the profile's skills/ directory and formatting them with paths, names, and descriptions from frontmatter. Configuration is stored in ~/nori-config.json with auth credentials and profile.baseProfile, checked by ConfigManager in @/plugin/src/api/base.ts. The installer is idempotent - running multiple times performs a clean uninstall of the previous version before installing the new version. Profile switching via /nori-switch-profile (implemented in @/plugin/src/installer/cli.ts) preserves both auth credentials and custom user profiles by calling installMain with skipUninstall=true, which bypasses the uninstall step entirely and updates profile.baseProfile in ~/nori-config.json. Changes to CLAUDE.md take effect in new conversations without requiring a Claude Code restart. Paid skills are prefixed with "paid-" in the source directory but installed without the prefix for paid tier users; free tier users skip paid- skills entirely. The build system (build.sh, bundle-skills.ts) bundles paid skill script.js files using esbuild to create standalone executables with all dependencies inlined, making them portable and executable from ~/.claude/skills/.

The installer creates an install-in-progress marker file at ~/.nori-install-in-progress at the start of installation (after tracking plugin_install_started event) and deletes it on successful completion (after saveInstalledVersion). This marker contains the version being installed and is checked by the statusline to display error messages if installation fails. If the marker persists after 24 hours, the statusline suggests manual removal. This mechanism ensures users are notified of failed autoupdate installations via the statusline rather than silently having an incomplete installation.

Analytics tracking is non-blocking - all operations in analytics.ts are wrapped in try/catch to ensure installation never fails due to analytics errors. The analytics module uses GA4 Measurement Protocol (measurement ID: G-3YXYKJK38T) for server-side event tracking from Node.js, sending HTTPS POST requests to www.google-analytics.com/mp/collect. Events tracked include plugin_analytics_initialized, plugin_install_started, plugin_install_completed, plugin_uninstall_started, plugin_uninstall_completed, and nori_session_started (tracked by autoupdate hook on SessionStart with metadata: installed_version, update_available, install_type). All events include tilework_event_user_id, tilework_user_id (set from nori-config.json username for paid users, null for free users), session_id, and engagement_time_msec parameters to match backend analytics conventions. The GA4_API_SECRET environment variable must be set for events to be sent to Google Analytics - without it, events are logged to console but not transmitted. A unique client_id is generated per installation session using crypto.randomUUID(). The trackEvent() function uses getInstallDirs({ currentDir: process.cwd() }) to locate the installation directory before loading config (v16.0.3+), ensuring it works correctly when called from subdirectories of the installation.

**Test Isolation:** Tests that perform file operations pass a temp directory as installDir to all functions. Since all functions now require installDir as a parameter, tests can directly pass a temporary directory path rather than mocking process.env.HOME. Tests follow this pattern: (1) create temp directory using fs.mkdtemp() in beforeEach, (2) pass tempDir as installDir to all function calls, (3) clean up temp directory with fs.rm(tempDir, { recursive: true, force: true }) in afterEach. For example: `loadDiskConfig({ installDir: tempDir })`, `getConfigPath({ installDir: tempDir })`, `hasExistingInstallation({ installDir: tempDir })`. This explicit parameter passing is safer than HOME mocking because it makes the file path dependency explicit and prevents any possibility of accidentally operating on real user files. Note that some tests still mock process.env.HOME for paid skill tests that use process.cwd() at runtime, but the core installer functions all use the explicit installDir parameter.
