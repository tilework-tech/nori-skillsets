# Noridoc: config

Path: @/src/cli/features/claude-code/hooks/config

### Overview

Executable hook scripts for conversation summarization, session statistics, desktop notifications, package auto-updates, nested installation warnings, context usage warnings, worktree disk usage warnings, onboarding wizard welcome messages, and instant slash command execution. Contains hook implementations that Claude Code invokes at lifecycle events: summarize.ts (memorizes conversations to backend), summarize-notification.ts (displays sync user notification), statistics.ts (calculates and displays session usage statistics), statistics-notification.ts (displays sync notification before statistics calculation), autoupdate.ts (checks and installs package updates), nested-install-warning.ts (warns about ancestor installations), context-usage-warning.ts (warns about excessive permissions consuming context tokens), worktree-cleanup.ts (warns about excessive git worktree disk usage), onboarding-wizard-welcome.ts (displays welcome message for first-time wizard users), notify-hook.sh (cross-platform desktop notifications), commit-author.ts (replaces Claude attribution with Nori in git commits), and slash-command-intercept.ts (intercepts slash commands for instant execution via registry pattern in intercepted-slashcommands/).

### How it fits into the larger codebase

This folder contains the actual hook implementations referenced by @/src/cli/features/claude-code/hooks/loader.ts in ~/.claude/settings.json. The hooks are executed by Claude Code at specific lifecycle events. The summarize.ts hook calls @/src/api/conversation.ts to create conversation artifacts in the backend. The statistics.ts hook parses the session transcript to calculate and display usage statistics (message counts, tool usage, skills used, subagents used, Nori CLAUDE.md detection). The autoupdate.ts hook uses npm to check for and install new versions of the nori-ai package. The nested-install-warning.ts hook uses findAncestorInstallations() from @/src/utils/path.ts to detect conflicting Nori installations in parent directories. The context-usage-warning.ts hook uses fs.stat() to check file sizes of settings.local.json files and warn when accumulated permissions consume excessive context tokens. The worktree-cleanup.ts hook uses git and POSIX commands to detect low disk space when worktrees exist. The onboarding-wizard-welcome.ts hook checks the user's profile and displays a welcome message for the onboarding wizard. The notify-hook.sh script provides cross-platform desktop notification support, summarize-notification.ts displays a quick message to users when transcripts are being saved, statistics-notification.ts displays a quick notification before statistics calculation, and slash-command-intercept.ts intercepts slash commands at the UserPromptSubmit event for instant execution without LLM inference overhead, delegating to command implementations in the intercepted-slashcommands/ subdirectory.

### Core Implementation

TypeScript files are compiled to JavaScript during build and executed directly via `node {script}.js` commands configured in settings.json. No shell script wrappers exist anymore (previously removed in favor of direct TypeScript execution).

**summarize.ts**: Accepts SessionEnd or PreCompact as first argument. Reads conversation data from process.argv[3] or stdin. Before processing, checks two conditions: (1) ConfigManager.isConfigured() ensures `.nori-config.json` exists (ConfigManager uses getInstallDirs() to locate the installation directory), (2) Uses getInstallDirs({ currentDir: process.cwd() }) to find the Nori installation directory (searching current directory and all parents), errors if no installation found, then calls loadConfig({ installDir }) to read sendSessionTranscript field and skips if set to 'disabled', displaying "Session Transcript disabled. Use /nori-toggle-session-transcripts to reenable" message. If enabled, parses conversation data JSON to extract transcript_path, reads the full transcript file, and filters empty transcripts using isEmptyTranscript() before calling apiClient.conversation.summarize(). Empty transcript detection checks for user messages with actual content - transcripts containing only metadata (file-history-snapshot, summaries) or only assistant messages are skipped with debug logging. Outputs `{async: true}` on startup to run asynchronously without blocking session end.

**summarize-notification.ts**: Synchronous SessionEnd hook that checks sendSessionTranscript configuration before outputting user feedback. Uses getInstallDirs({ currentDir: process.cwd() }) to find the Nori installation directory (searching current directory and all parents). All output goes to stderr via `console.error()` with ANSI formatting from `formatWithLineClear()` in intercepted-slashcommands/format.ts. The hook exits with code 2 to trigger Claude Code's failure display mechanism (which shows stderr to users), then uses ANSI escape codes to clear the "SessionEnd hook [path] failed:" prefix that Claude Code would otherwise display. Error handling: if no installation found or config loading fails, shows a red error message: "Error saving to Nori Watchtower. Check /tmp/nori.log for details." (errors are also logged to /tmp/nori.log via `debug()`). When installation is found and sendSessionTranscript is 'disabled', outputs green success message: "Session transcripts disabled. Use /nori-toggle-session-transcripts to enable...". When enabled (or missing for backward compatibility), outputs green success message: "Saving transcript to nori...". Provides immediate user feedback about transcript state while summarize.ts runs asynchronously in background. Exports main as async function to support config loading.

**statistics.ts**: SessionEnd hook that calculates and displays session usage statistics. Runs synchronously (unlike summarize.ts) because statistics calculation is purely local JSON parsing without any API calls or network I/O - it completes fast enough that async execution would add unnecessary complexity. Reads conversation data from stdin JSON, extracts transcript_path field, and reads the full transcript file (same pattern as summarize.ts). Parses the newline-delimited JSON transcript to calculate: (1) user/assistant message counts via countMessages(), (2) tool usage breakdown via countToolUsage() which counts tool_use content items grouped by tool name, (3) skill usage via parseSkillUsage() which detects Read tool invocations targeting paths matching `~/.claude/skills/*/SKILL.md`, (4) subagent usage via parseSubagentUsage() which detects Task tool invocations with subagent_type input, (5) Nori CLAUDE.md detection via detectNoriClaudeMd() which searches for markers like "NORI-AI MANAGED BLOCK" or "Following Nori workflow" in transcript content. Formats statistics as ASCII table via formatStatistics() showing: header "Session Statistics", message counts, top 5 tools by usage, skills list with counts, subagents list with counts, and CLAUDE.md status. Outputs to stderr via `console.error()` with `formatWithLineClear()` from intercepted-slashcommands/format.ts, which clears Claude Code's "failed:" prefix using ANSI escape codes before displaying the green-colored statistics. Exits with code 2 to trigger display. All errors are caught and exit with code 0 to avoid disrupting Claude Code sessions.

**statistics-notification.ts**: Synchronous SessionEnd hook that displays "Calculating Nori statistics... (Ctrl-C to exit early)" to inform users that statistics are being computed. Uses getInstallDirs({ currentDir: process.cwd() }) to find the Nori installation directory, exits silently if no installation found (errors logged to /tmp/nori.log via `debug()`). Outputs to stderr via `console.error()` with `formatWithLineClear()` from intercepted-slashcommands/format.ts, which clears Claude Code's "failed:" prefix using ANSI escape codes before displaying the green-colored message. Exits with code 2 to trigger Claude Code's failure display mechanism. Silent error handling to prevent session crashes.

**autoupdate.ts**: SessionStart hook that tracks session starts via Google Analytics and checks for package updates. The hook executes in the context of Claude Code's current working directory, which may be a subdirectory of the Nori installation. To locate the config file, the hook first checks if cwd contains a Nori installation using hasNoriInstallation({ dir: cwd }). If not found in cwd, it searches parent directories using findAncestorInstallations({ installDir: cwd }) and uses the closest ancestor installation as the config directory. If no config directory is found, it logs an error to `/tmp/nori.log` and exits early. Once the config directory is identified, it loads the config using loadConfig({ installDir: configDir }). The Config contains the true installDir (not the configDir itself), which is where Nori is actually installed. The hook then validates that this installDir exists on the filesystem - if the config specifies an installDir that no longer exists, it logs an error and exits.

On successful config load with valid installDir, the hook checks if `diskConfig.version == null` and throws an error with message "Installation out of date: no version field found in .nori-config.json file." - this ensures old installations without version tracking fail loudly rather than silently assuming a default version. The hook then tracks `nori_session_started` event with metadata: installed_version (from `diskConfig.version`), update_available (boolean), and install_type ('paid' if auth credentials exist, 'free' otherwise). The tracking call is asynchronous with silent failure to never disrupt session startup. The hook then compares installed version against latest npm registry version using `npm view nori-ai version` and semantic version comparison via the semver package. Uses semver.valid() to validate the npm version string, then semver.gt() to check if latestVersion > installedVersion. This prevents downgrades when local nightly builds (e.g., 14.2.0-nightly.20250120) have higher version numbers than published releases (e.g., 14.1.0), and gracefully handles malformed versions from npm.

When an update is available (latestVersion is valid AND greater than installedVersion), the hook checks the `autoupdate` config field. If `config.autoupdate === "disabled"`, it notifies the user with a systemMessage indicating the new version is available but autoupdate is disabled, suggesting manual update via `npx nori-ai install`. Analytics still track update availability even when autoupdate is disabled. If autoupdate is enabled (default), it spawns a detached background process running `npx nori-ai@{version} install --install-dir={installDir} --non-interactive` to install update and re-run installer preserving user config. The installDir passed to npx is the actual installDir from the config, not the current working directory. Uses openSync() to obtain a file descriptor for redirecting spawn stdio to `/tmp/nori.log` (consolidated log file for all Nori output) - detached spawns require file descriptors (integers), not stream objects. Registers error event listener on child process to log spawn failures and exit event listener to close file descriptor and prevent resource leaks. Outputs systemMessage with version upgrade notification.

**nested-install-warning.ts**: SessionStart hook that warns when multiple Nori installations exist in the directory tree (current directory + ancestors). Loads config to get the installation directory (defaulting to cwd if not set), normalizes it using normalizeInstallDir(). If installDir ends with `.claude`, uses the parent directory to avoid skipping the current installation. Then calls getInstallDirs() from @/src/utils/path.ts to detect ALL directories with Nori installations (including the current directory). Only warns when `allInstallations.length >= 2` - this prevents false warnings when there is a single installation in a parent directory but no installation in the current directory. When multiple installations are detected, builds a systemMessage warning about Claude Code's recursive CLAUDE.md loading behavior and lists ALL installation paths (not just ancestors) with uninstall commands for each. The warning message header is "All Nori installations found:" to reflect that all installations are listed (not just ancestors). The hook uses logToClaudeSession() helper to output JSON with systemMessage field for Claude Code to display. All errors are caught and logged silently with exit code 0 to prevent disrupting session startup.

**context-usage-warning.ts**: SessionStart hook that warns when accumulated permissions in settings.local.json files consume excessive context tokens. Claude Code stores user-approved permissions (e.g., `Bash(git push)`, `Bash(npm test)`) in settings.local.json files at both home level (`~/.claude/settings.local.json`) and project level (`.claude/settings.local.json`). These permissions are embedded in the system prompt and consume context tokens. The hook uses `fs.stat()` to check file sizes (performance optimization over reading/parsing JSON), summing home and project file sizes. Uses a 10KB threshold (~2.5k tokens at 4 bytes per token ratio). When threshold is exceeded, outputs a systemMessage warning with estimated token usage and suggests running `/nori-prune-context` to clear accumulated permissions. Silent failure (errors caught and logged via `error()` function, exits with code 0) to never disrupt session startup. The 4 bytes per token ratio is derived from empirical observation (86KB file â‰ˆ 21k tokens).

**worktree-cleanup.ts**: SessionStart hook that warns users when disk space is low and git worktrees exist. Triggers only when system disk space is below 10% remaining (`DISK_SPACE_LOW_PERCENT`) AND at least one additional worktree exists - the previous 50GB worktree size threshold was removed for performance reasons. Uses `git worktree list --porcelain` to discover all worktrees, skipping the first entry (main worktree). Uses `df -Pk` for disk space information (POSIX-compliant for cross-platform compatibility on macOS and Linux). When triggered, outputs a structured `<required>` block with TodoWrite instructions directing Claude to report the worktree count and remaining disk space percentage, then ask the user about cleanup. The hook uses logToClaudeSession() helper to output JSON with hookSpecificOutput.additionalContext field for Claude Code to display. Exits silently (code 0) if: not in a git repository, no additional worktrees exist, or disk space is above threshold. All errors are caught and logged via `error()` function with graceful exit to avoid disrupting session startup.

**onboarding-wizard-welcome.ts**: SessionStart hook that displays a welcome message when the user's current profile is `onboarding-wizard-questionnaire`. This hook supports the first-time user onboarding flow: when new users select the wizard option during installation (via @/src/cli/commands/install/install.ts), this hook greets them with instructions on how to start the profile creation wizard. Uses getInstallDirs({ currentDir: process.cwd() }) to locate the Nori installation directory, loads config via loadConfig({ installDir }), and checks if the claude-code agent's baseProfile is `onboarding-wizard-questionnaire` using getAgentProfile({ config, agentName: "claude-code" }). If not using the wizard profile, the hook exits silently (no output). When the wizard profile is active, outputs a systemMessage with emoji welcome banner ("Welcome to the Nori Profile Setup Wizard!") and instructions to type anything to begin. The hook uses logToClaudeSession() helper to output JSON with systemMessage field. All errors are caught and logged via `error()` function with graceful exit (code 0) to avoid disrupting session startup.

**notify-hook.sh**: Shell script (only remaining shell script in config/) that reads JSON notification data from stdin. Logs to the consolidated log file at `/tmp/nori.log`. Parses message field using python3/jq/node/sed fallbacks for portability. Platform detection via `uname -s` determines notification method: Linux uses notify-send with click-to-focus actions (X11 only, requires wmctrl/xdotool), macOS tries terminal-notifier with click-to-focus then falls back to osascript (not clickable), Windows tries BurntToast PowerShell module then Windows Forms then msg.exe. Captures terminal window ID on Linux X11 using xdotool before sending notification, then restores focus when user clicks. macOS click-to-focus auto-detects terminal app bundle ID from $TERM_PROGRAM environment variable. Gracefully degrades to basic notifications on Wayland or when optional dependencies are missing.

**slash-command-intercept.ts**: UserPromptSubmit hook that intercepts slash commands for instant execution without LLM inference overhead. Reads stdin JSON containing prompt, cwd, session_id, and other Claude Code context. Iterates through registered commands from `intercepted-slashcommands/registry.ts`, testing each command's matchers (regex patterns) against the trimmed prompt. The first matching command's `run()` function is executed, and its result is output as JSON. If no command matches, the hook passes through silently (exits with code 0). All errors are caught and exit silently to avoid disrupting Claude Code sessions.

**intercepted-slashcommands/**: Subdirectory containing the registry pattern for slash command interception. Includes:

- `types.ts`: Defines `HookInput` (prompt, cwd, session_id, transcript_path, permission_mode, hook_event_name), `HookOutput` (decision, reason, hookSpecificOutput), and `InterceptedSlashCommand` interface (matchers array of regex strings, async run function).

- `registry.ts`: Exports `interceptedSlashCommands` array containing all registered commands. Commands are checked in order, first match wins. All matchers should be unique across commands.

- `format.ts`: Provides formatting utilities for consistent ANSI colored output across all intercepted slash commands and SessionEnd hooks. Uses green for success/help messages and red for error messages. The implementation uses per-word coloring: each non-whitespace token is individually wrapped with color codes (e.g., `\x1b[0;32mword\x1b[0m`), while whitespace is preserved uncolored. This ensures colors persist correctly across terminal soft wraps at any terminal width, as color codes reset at each word boundary rather than depending on pre-calculated line breaks. Key exports:
  - `formatSuccess()` / `formatError()`: Apply green/red coloring with per-word wrapping
  - `calculatePrefixLines()`: Calculates how many terminal lines Claude Code's hook failure prefix occupies (format: `SessionEnd hook [node {hookPath}] failed: `), using terminal width from `process.stdout.columns` (defaults to 80)
  - `formatWithLineClear()`: Prepends ANSI escape codes to clear the Claude Code prefix before displaying colored output. Uses `\x1b[{n}A` (cursor up n lines) and `\x1b[J` (clear to end of screen) to remove the unwanted "failed:" prefix, then applies success/error coloring

- `nori-install-location.ts`: Returns the Nori installation directory (or directories if multiple found). Uses getInstallDirs() to locate installations from cwd upward.

- `nori-prune-context.ts`: Handles `/nori-prune-context` to clear accumulated permissions from settings.local.json files and reduce context token usage. Prunes both home-level (`~/.claude/settings.local.json`) and project-level (`.claude/settings.local.json`) files. The `pruneSettingsFile()` function reads JSON, creates a `.backup` file, clears only the `permissions.allow` array, and writes updated settings. Preserves `permissions.deny` and `permissions.ask` arrays (intentional security choices). Handles missing files gracefully (returns 0 pruned count). Reports total permissions pruned and lists backup file paths on success.

- `nori-switch-profile.ts`: Handles `/nori-switch-profile` with or without profile name argument. Uses getInstallDirs({ currentDir: cwd }) to locate the Nori installation directory. Locates profiles at `{installDir}/.claude/profiles/` and config at `{installDir}/.nori-config.json`. Without profile name, lists available profiles. With profile name, calls `agent.switchProfile()` to update config, then runs `nori-ai install` via subprocess (`execSync`) to apply profile changes immediately (skills, CLAUDE.md, etc.). The subprocess approach is required because this hook script is bundled by esbuild - when bundled, `__dirname` resolves to the bundled script location (`hooks/config/`) instead of the original loader locations, breaking path resolution if dynamic import were used. Spawning `nori-ai` as a subprocess runs the CLI from its installed location where paths resolve correctly (see esbuild issue #1921). **Console output suppression uses two mechanisms:** (1) `setSilentMode({ silent: true })` wraps the `agent.switchProfile()` call to suppress logger output (success/info messages) from the parent process, (2) the install subprocess uses `--silent` flag and `stdio: ["ignore", "ignore", "ignore"]` to suppress child process output. Both are necessary because Claude Code hooks must output only valid JSON to stdout - any extraneous output causes the hook to fail and fall through to the LLM. The `setSilentMode()` is restored in a `finally` block to ensure logging resumes even on error. This mirrors the CLI `nori-ai switch-profile` command behavior. Profile descriptions are read from `profile.json` if available. The user is still prompted to restart Claude Code after switching to ensure the new profile takes full effect.

- `nori-toggle-autoupdate.ts`: Toggles the `autoupdate` field in `.nori-config.json` between "enabled" and "disabled". Default state (missing field) is treated as disabled, requiring users to explicitly opt-in to automatic updates.

- `nori-toggle-session-transcripts.ts`: Toggles the `sendSessionTranscript` field in `.nori-config.json` between "enabled" and "disabled". Default state (missing field) is treated as enabled.

- `nori-registry-search.ts`: Handles `/nori-registry-search <query>` to search for profile packages across all configured registries (public + private). The command always searches the public registrar at `REGISTRAR_URL`, then iterates through any private registries in `config.registryAuths` using `getRegistryAuthToken()` for authentication. Uses `registrarApi.searchPackagesOnRegistry()` from @/src/api/registrar.ts to search each registry with optional Bearer token. Deduplicates registries using `normalizeUrl()` to avoid searching the same registry twice (e.g., if a private registry URL matches the public one). Results are grouped by registry URL in the output format:
  ```
  https://registrar.tilework.tech
    -> package-name: Description...

  https://private.registry.com
    -> another-package: Description...
  ```
  Error handling is per-registry: failures in one registry don't prevent searching others. Registries with no results are omitted from output; registries with errors display the error message under their URL.

- `nori-registry-download.ts`: Handles `/nori-registry-download <package-name>[@version] [registry-url]` to download and install profile packages from Nori registries. Supports multi-registry search: when no registry URL is provided, searches the public registry first, then all private registries configured in `.nori-config.json` `registryAuths` array. If the package is found in multiple registries, shows a disambiguation error with options. When a specific registry URL is provided, searches only that registry. Uses `getRegistryAuthToken()` from @/src/api/registryAuth.ts to obtain auth tokens for private registries. Uses registrarApi.downloadTarball() to fetch the tarball, then extracts it using the `tar` npm package with zlib gzip decompression. Installs profiles to `{installDir}/.claude/profiles/{packageName}/`. Checks for existing installations and refuses to overwrite. Requires exactly one Nori installation to be detected (errors if multiple installations found). **Version listing**: Supports `--list-versions` flag to display all available versions with timestamps and dist-tags without downloading (e.g., `/nori-registry-download --list-versions my-profile`). **Version tracking**: After successful download, creates a `.nori-version` JSON file in the profile directory containing `{ version, registryUrl }` - this file enables the update command to track installed versions and their source registry.

- `nori-registry-upload.ts`: Handles `/nori-registry-upload <profile-name> [version] [registry-url]` to upload a local profile to a configured registry. Supports multi-registry: when a single registry is configured in `registryAuths`, uploads automatically; when multiple registries exist, requires explicit registry URL or displays error listing available registries with example commands. Uses `getRegistryAuth()` from @/src/cli/config.ts to look up credentials for the specified registry URL, then `getRegistryAuthToken()` from @/src/api/registryAuth.ts to obtain a Firebase ID token. Creates a gzipped tarball from the profile directory using the `tar` npm package, then uploads via registrarApi.uploadProfile() with the target registry URL. **Automatic version bumping**: When no version is specified, `determineUploadVersion()` fetches the packument from the registry via `registrarApi.getPackument()` to find the current latest version. If the package exists, it auto-bumps the patch version using `semver.inc(latestVersion, 'patch')` (e.g., 1.2.3 -> 1.2.4). If the package doesn't exist, defaults to "1.0.0". Users can override this with an explicit `--version` flag. Requires exactly one Nori installation to be detected (errors if multiple installations found). Unlike search/download (which query multiple registries), upload targets a SINGLE registry - this is an intentional architectural difference since publishing to multiple registries simultaneously would create version synchronization issues.

- `nori-registry-update.ts`: Handles `/nori-registry-update <profile-name> [registry-url]` to update an installed profile to the latest version from its source registry. Reads the `.nori-version` file from the profile directory to determine the currently installed version and original registry URL. If no `.nori-version` file exists (manual install or old Nori version), displays an error suggesting reinstallation. Fetches the packument from the registry via `registrarApi.getPackument()` to get the latest version. Uses `semver.gt()` to compare versions - if installed version >= latest, reports profile is up to date. For updates: removes all profile files except `.nori-version`, extracts the new tarball, then updates `.nori-version` with the new version. Supports registry URL override: if provided, uses the override URL instead of the stored registry URL (useful for migrating profiles between registries). Handles prerelease versions correctly via semver comparison (e.g., 1.0.0-beta.1 < 1.0.0). Uses the same tarball extraction logic as the download command (`isGzipped()` check, zlib gunzip, tar extract).

- `nori-skill-search.ts`: Handles `/nori-skill-search <query>` to search for skill packages in the user's org registry. Unlike profile search (which queries all registries), skill search requires org-based authentication via `config.auth`. The command derives the registry URL from `config.auth.organizationUrl` using `extractOrgId()` and `buildRegistryUrl()` from @/src/utils/url.ts. If no org is configured, displays an error directing users to run `nori-ai install`. Uses `registrarApi.searchSkills()` from @/src/api/registrar.ts with Bearer token authentication. Results display the registry URL followed by matching skill names and descriptions.

- `nori-skill-download.ts`: Handles `/nori-skill-download <skill-name>[@version] [--registry <url>] [--list-versions]` to download and install skill packages to `~/.nori/skills/{skill-name}/`. Supports multi-registry search: when no registry URL is provided, searches the public registry first, then all private registries in `config.registryAuths`. If the skill is found in multiple registries, shows a disambiguation error with options. Uses `registrarApi.downloadSkillTarball()` and `registrarApi.getSkillPackument()` for download and version lookup. **Version tracking**: Creates a `.nori-version` JSON file containing `{ version, registryUrl }` after successful download. **Update detection**: If skill already exists with a `.nori-version` file, compares versions using `semver.gte()` - skips download if installed version is same or newer, otherwise extracts to temp directory first, then atomically replaces existing skill files. Supports `--list-versions` flag to display all available versions with timestamps.

- `nori-skill-upload.ts`: Handles `/nori-skill-upload <skill-name> [version] [registry-url]` to upload a skill from `~/.nori/skills/{skill-name}/` to a configured registry. Validates that the skill exists and has a SKILL.md file. Extracts optional description from SKILL.md YAML frontmatter via `parseSkillMdFrontmatter()`. Supports both org-based auth (`config.auth` with organizationUrl) and legacy `registryAuths`. When multiple registries are configured, requires explicit registry URL or displays error listing available registries. **Automatic version bumping**: When no version specified, `determineUploadVersion()` fetches the packument via `registrarApi.getSkillPackument()` and auto-bumps the patch version (e.g., 1.2.3 -> 1.2.4). If skill doesn't exist in registry, defaults to "1.0.0". Creates tarball using `tar` npm package and uploads via `registrarApi.uploadSkill()`.

All intercepted slash commands use `formatSuccess()` and `formatError()` from format.ts to wrap their `reason` output strings, ensuring consistent colored terminal output.

**Slash Command Markdown Structure for Hook-Intercepted Commands**: Hook-intercepted slash commands still have corresponding `.md` files in the profiles slashcommands directories (e.g., `nori-switch-profile.md`, `nori-toggle-autoupdate.md`). These markdown files serve two purposes: (1) the frontmatter `description` appears in Claude Code's command palette, (2) the body provides user-facing documentation. Critically, these files do NOT need `allowed-tools` frontmatter because the hook intercepts and executes the command directly - the LLM never processes the slash command body. Only non-intercepted slash commands (like `nori-debug.md`) that use the `!command` syntax need `allowed-tools` to grant Claude Code permission to execute commands.

### Things to Know

Hook execution is controlled by @/src/cli/features/claude-code/hooks/loader.ts configuration: paid installations install all hooks (summarize, summarize-notification, statistics, statistics-notification, autoupdate, nested-install-warning, context-usage-warning, worktree-cleanup, onboarding-wizard-welcome, notify, slash-command-intercept, commit-author), free installations get statistics, statistics-notification, autoupdate, nested-install-warning, context-usage-warning, worktree-cleanup, onboarding-wizard-welcome, notify, slash-command-intercept, and commit-author. The summarize-notification hook must be registered before summarize hook in loader.ts to ensure synchronous user notification appears before async background summarization. Similarly, statistics-notification must be registered before statistics hook to show users a notification message before statistics calculation.

TypeScript hooks use different output mechanisms depending on their purpose. Most hooks use JSON.stringify() to output structured responses to stdout: summarize.ts outputs `{async: true}` to run non-blocking (required because it makes API calls to the backend), while autoupdate.ts, nested-install-warning.ts, context-usage-warning.ts, and onboarding-wizard-welcome.ts output `{systemMessage: "..."}` while worktree-cleanup.ts outputs `{hookSpecificOutput: {additionalContext: "..."}}` with structured TodoWrite instructions to inject messages into Claude sessions. However, summarize-notification.ts, statistics-notification.ts, and statistics.ts output directly to stderr via `console.error()` with ANSI escape code formatting from `formatWithLineClear()` in intercepted-slashcommands/format.ts. These hooks exit with code 2 to trigger Claude Code's failure display mechanism (Claude Code only shows stderr to users when hooks exit with non-zero codes), then use ANSI escape codes (`\x1b[{n}A` cursor up, `\x1b[J` clear to end) to erase the "SessionEnd hook [path] failed:" prefix that Claude Code would otherwise display. The `calculatePrefixLines()` function determines how many terminal lines the prefix occupies based on terminal width and hook path length. Note: statistics.ts runs synchronously because it only performs local JSON parsing - no network I/O is needed, so async execution would add unnecessary complexity. Error handling is strictly non-fatal - all hooks catch errors, log via debug() function, and exit with code 0 to prevent disrupting Claude Code sessions. Both summarize.ts and summarize-notification.ts check sendSessionTranscript configuration: (1) summarize.ts performs ConfigManager.isConfigured() to ensure `.nori-config.json` exists (ConfigManager uses getInstallDirs() to locate the installation directory), then uses getInstallDirs() again to find the config file location and calls loadConfig({ installDir }) to check sendSessionTranscript field, exiting early with a systemMessage when disabled; (2) summarize-notification.ts uses getInstallDirs() to find the config file location and calls loadConfig({ installDir }) to check the same field, displaying appropriate user feedback ("Saving transcript..." when enabled, "Session transcripts disabled..." when disabled). This ensures consistent user messaging about transcript state across both hooks.

**Bug Fix (v16.0.3+):** Prior versions of summarize.ts, summarize-notification.ts, and analytics.ts incorrectly used `process.cwd()` directly as the installDir when loading configuration, instead of using the standard getInstallDirs() pattern. This caused the sendSessionTranscript setting to be ignored when Claude Code was invoked from a subdirectory of the Nori installation (e.g., running from `~/project/src` when Nori is installed at `~/project`), as the hooks would look for `.nori-config.json` at the cwd instead of searching upward through parent directories. The fix ensures all three files now use getInstallDirs({ currentDir: process.cwd() }), check if allInstallations.length === 0, and use allInstallations[0] as the installDir - matching the pattern already used in autoupdate.ts, slash-command-intercept.ts, ConfigManager, and all paid skill scripts.

**Registry Version Tracking via `.nori-version`:** Downloaded profiles include a `.nori-version` JSON file containing `{ version: string, registryUrl: string }`. This file is created by `nori-registry-download.ts` after successful extraction and updated by `nori-registry-update.ts` after updates. The file serves two purposes: (1) tracking the installed version for update comparison via `semver.gt()`, and (2) storing the source registry URL so updates come from the same registry. Profiles installed manually or before this feature lack this file and cannot be updated via `/nori-registry-update` (error message suggests reinstallation). All registry commands use the `semver` npm package for version comparison and bumping.

**Installation Directory Resolution Pattern:** All hooks, skill scripts, slash commands, and the API client MUST use getInstallDirs() from @/src/utils/path.ts to locate the Nori installation directory. This is CRITICAL because Claude Code may execute these scripts from various directories including `~/.claude` or its subdirectories. The pattern is: (1) Call `getInstallDirs({ currentDir: process.cwd() })` at the start of main() or loadConfig(), (2) Check if the returned array is empty - if so, fail loudly with "Error: No Nori installation found." and exit(1) or throw an error, (3) Use `allInstallations[0]` as the installDir for all subsequent path operations (config file, profiles directory, etc.). For TypeScript hooks and skills, this is done via the getInstallDirs() function. For bash-based slash commands, this is done by walking up directories checking for `.nori-config.json` files, following the same logic as getInstallDirs(). This pattern replaced previous approaches that used `process.cwd()` or hardcoded paths like `~/nori-config.json` directly. The getInstallDirs function walks up the directory tree from currentDir (starting from the immediate parent) to find all directories containing Nori installation markers (`.nori-config.json`, legacy `nori-config.json`, or `.claude/CLAUDE.md` with "NORI-AI MANAGED BLOCK"), returning them in closest-to-furthest order. Never fall back silently to cwd - always fail loudly with a clear error message when no installation is found. This pattern is implemented in all intercepted slash commands (intercepted-slashcommands/*.ts), all paid skill scripts (paid-recall, paid-memorize, paid-list-noridocs, paid-read-noridoc, paid-write-noridoc, nori-sync-docs), and ConfigManager.loadConfig() in @/src/api/base.ts.

The isEmptyTranscript() function (exported for testing in summarize.test.ts) uses strict content validation: parses newline-delimited JSON transcript, filters for user message types, and checks if message content (string or array with text) contains non-whitespace. Only transcripts with at least one substantive user message are sent to backend. This prevents unnecessary API calls for metadata-only sessions (file-history-snapshot, auto-compaction summaries, assistant-only exchanges).

The autoupdate.ts spawn mechanism is a critical system boundary - it must be non-blocking to allow Claude Code session to start immediately. The detached spawn pattern with unref() allows the parent process to exit while the update continues in background. IMPORTANT: Node.js spawn() with detached: true requires file descriptors (integers) for stdio, NOT stream objects. Using createWriteStream() causes silent spawn failures because streams cannot be used as stdio in detached mode. The openSync(path, 'a') pattern is required to get a file descriptor for appending to `/tmp/nori.log`. The error event listener catches spawn failures (e.g., npx not in PATH) and logs to the same file since the parent process exits immediately. The exit event listener closes the file descriptor to prevent resource leaks - without it, file descriptors accumulate across session starts.

**Subprocess pattern for bundled hooks:** Hook scripts in this directory are bundled by esbuild (via @/src/scripts/bundle-skills.ts) into standalone executables. When bundled, `__dirname` resolves to the bundled script's location (`hooks/config/`) instead of the original source file locations. This breaks dynamic imports that rely on relative path resolution (e.g., `import("@/cli/commands/install/install.js")` would fail because the bundled code's `__dirname` points to `hooks/config/` instead of the CLI commands directory). The solution is to use subprocess invocation (`execSync` or `spawn`) to run CLI commands like `nori-ai install`. This runs the CLI from its installed npm location where all path resolution works correctly. This pattern is used by `nori-switch-profile.ts` (uses `execSync("nori-ai install ...")`) and `autoupdate.ts` (uses `spawn("npx", ["nori-ai@version", "install", ...])`). See esbuild issue #1921 for background on the `__dirname` resolution problem in bundled ESM.

Historical note: This directory previously contained abilities-context.ts and skills-context.ts hooks for SessionStart ability/skill discovery. Both were removed - abilities-context.ts was renamed to skills-context.ts during superpowers integration (#104), then skills-context.ts was deleted when skill discovery moved to hardcoded CLAUDE.md generation at install time (#120). Shell script wrappers (autoupdate.sh, summarize.sh, summarize-notification.sh) were also removed in favor of direct TypeScript execution via node commands.

**Nested installation warning bug fix**: Prior to v15.3.0, nested-install-warning.ts used `findAncestorInstallations()` which only checked parent directories, and warned whenever `ancestorInstallations.length > 0`. This caused false warnings when a user had a single Nori installation in a parent directory (e.g., `/home/user/.claude`) but was working in a subdirectory with no installation (e.g., `/home/user/code/project`). The hook incorrectly treated this as a "nested" scenario when in reality only ONE installation existed. The initial fix attempted to change the logic to check `ancestorInstallations.length < 2`, but this introduced a new bug: it required 3+ total installations to trigger the warning (current + 2 ancestors), missing the common case of 2 installations (one at ~ and one at ~/foo/bar). The correct fix (implemented in v16.0.2) uses `getInstallDirs()` to get ALL installations in the directory tree and checks `allInstallations.length >= 2`. Additionally, when installDir ends with `.claude`, the hook now uses the parent directory as the search starting point to ensure the current installation is properly included in the count. This ensures warnings only appear when there are genuinely 2+ installations that would cause Claude Code to load duplicate CLAUDE.md files.

### Optional Dependencies for Click-to-Focus Notifications

The notify-hook.sh script sends desktop notifications when Claude needs attention. By default, notifications work on all platforms but may not support click-to-focus behavior without optional dependencies.

**Linux (X11)**

For clickable notifications that return focus to your terminal, install:

**Ubuntu/Debian:**

```bash
sudo apt-get install libnotify-bin wmctrl xdotool
```

**Fedora:**

```bash
sudo dnf install libnotify wmctrl xdotool
```

**Arch:**

```bash
sudo pacman -S libnotify wmctrl xdotool
```

**Note:** Click-to-focus is not supported on Wayland yet. Basic notifications will still work, but clicking them won't restore terminal focus. The script auto-detects Wayland via $XDG_SESSION_TYPE and gracefully degrades to basic notifications.

**macOS**

For clickable notifications that return focus to your terminal, install terminal-notifier via Homebrew:

```bash
brew install terminal-notifier
```

Without terminal-notifier, notifications will appear via osascript but won't be clickable (clicking opens Script Editor instead).

**Windows**

Windows notifications use built-in PowerShell commands and don't require additional dependencies. Click-to-focus is not currently implemented for Windows.
